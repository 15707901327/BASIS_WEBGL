<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>WebGL上下文</title>
  <link rel="stylesheet" href="../../css/base.css">
</head>
<body>
<div class="l-r-wrapper">
  <div class="left">
    <h4>绘制图形的基本方法</h4>
    <a href="#drawArrays">gl.drawArrays()</a><br>
    <a href="#clear">gl.clear()</a><br>
    <a href="#clearColor">gl.clearColor()</a>
    <h4>与attribute变量相关方法</h4>
    <a href="#getAttribLocation">gl.getAttribLocation()</a>
    <a href="#vertexAttrib[1234]f">gl.vertexAttrib[1234]f()</a>
    <a href="#vertexAttribPointer">gl.vertexAttribPointer()</a>
    <h4>与uniform变量相关方法</h4>
    <a href="#getUniformLocation" title="gl.getUniformLocation()">gl.getUniformLocation()</a>
    <a href="#uniform" title="gl.uniform()">gl.uniform()</a>
    <a href="#uniformMatrix4fv" title="gl.uniformMatrix4fv()">gl.uniformMatrix4fv()</a>
    <h4>与缓存区相关方法</h4>
    <a href="#createBuffer" title="gl.createBuffer()">gl.createBuffer()</a>
    <a href="#deleteBuffer" title="gl.deleteBuffer()">gl.deleteBuffer()</a>
    <a href="#bindBuffer" title="gl.bindBuffer()">gl.bindBuffer()</a>
    <a href="#enableVertexAttribArray" title="gl.enableVertexAttribArray()">gl.enableVertexAttribArray()</a>
    <a href="#disableVertexAttribArray" title="gl.disableVertexAttribArray()">gl.disableVertexAttribArray()</a>
    <h4>与加载纹理相关的方法</h4>
    <a href="#createTexture" title="gl.createTexture()">gl.createTexture()</a>
    <a href="#deleteTexture" title="gl.deleteTexture()">gl.deleteTexture()</a>
    <a href="#pixelStorei" title="gl.pixelStorei()">gl.pixelStorei()</a>
    <a href="#activeTexture" title="gl.activeTexture()">gl.activeTexture()</a>
    <a href="#bindTexture" title="gl.bindTexture()">gl.bindTexture()</a>
    <a href="#texParameteri" title="gl.texParameteri()">gl.texParameteri()</a>
    <a href="#texImage2D" title="gl.texImage2D()">gl.texImage2D()</a>
  </div>
  <div class="right">
    <!--绘制图形的基本方法-->
    <section id="drawArrays">
      <h4>gl.drawArrays(mode, first, count);</h4>
      <p>执行顶点着色器，按照mode参数指定的方式绘制图形</p>
      <div class="content">
        <strong>参数：</strong>
        <ul>
          <li>
            mode：指定绘制的方式，可以接收一下常量符号：gl_POINTS,gl_LINES,gl_LINE_STRIP,
            gl_LINE_LOOP,gl_TRIANGLES,gl_TRIANGLE_STRIP,gl_TRIANGLE_FAN.
            <p>参考:<a href="../WebGL可以绘制的基本图形.html">WebGL可以绘制的基本图形</a></p>
          </li>
          <li>first:指定从那个顶点开始绘制</li>
          <li>count：指定绘制需要用到多少个顶点（整形数）</li>
        </ul>
        <strong>返回值：</strong>
        <p>无</p>
        <strong>错误：</strong>
        <ul>
          <li>INVALID_ENUM：传入的mode参数不是前述参数之一</li>
          <li>INVALID_VALUE：参数first或count是负数</li>
        </ul>
      </div>
    </section>
    <section id="clear">
      <h4>gl.clear(buffer);</h4>
      <p>将指定缓存区设定为预定的值。如果清空是颜色缓存区，那么将使用gl.clearColor()指定的值（作为预定值）</p>
      <div class="content">
        <strong>参数：</strong>
        <ul>
          <li>
            buffer：指定待清空的缓存区，位操作符OR(|)可用来指定多个缓存区<br>
            gl.COLOR_BUFFER_BIT：指定颜色缓存区<br>
            gl.DEPTH_BUFFER_BIT：指定深度缓存区<br>
            gl.STENCIL_BUFFER_BIT：指定模版缓存区<br>
          </li>
        </ul>
        <strong>返回值：</strong>
        <p>无</p>
        <strong>错误：</strong>
        <ul>
          <li>INVALID_VALUE：缓存区不是以上三种类型</li>
        </ul>
      </div>
    </section>
    <section id="clearColor">
      <h4>gl.clearColor(red,green,blue,alpha);</h4>
      <p>指定绘图区域的背景色</p>
      <div class="content">
        <strong>参数：</strong>
        <ul>
          <li>red：指定红色值（从0.0到1.0）</li>
          <li>green：指定绿色值（从0.0到1.0）</li>
          <li>blue：指定蓝色值（从0.0到1.0）</li>
          <li>alpha：指定透明度值（从0.0到1.0,如果任何值小于0.0大于1.0，那么就会分别截断为0.0或1.0</li>
        </ul>
        <strong>返回值：</strong>
        <p>无</p>
        <strong>说明：</strong>
        <ul>
          <li>一旦指定背景颜色之后，背景颜色就会被驻存在WebGL系统（WebGL System）中，在下一次调用方法之前不会改变（只需要要设置一次）。</li>
        </ul>
      </div>
    </section>
    <!--与attribute变量相关方-->
    <section id="getAttribLocation">
      <h4>gl.getAttribLocation(gl.program, name);</h4>
      <p>获取由name参数指定的attribute变量的存储位置</p>
      <div class="content">
        <strong>参数：</strong>
        <ul>
          <li>gl.program：指定包含顶点着色器和片元着色器的着色器程序对象。</li>
          <li>name：指定想要获取其存储地址的attribute变量的名称</li>
          <li>name：指定想要获取其存储地址的attribute变量的名称</li>
        </ul>
        <strong>返回值：</strong>
        <ul>
          <li>大于等于0：attribute变量的存储地址</li>
          <li>-1：指定的attribute变量不存在，或者其命名具有gl_或webgl_前缀</li>
        </ul>
        <strong>错误：</strong>
        <ul>
          <li>INVALID_OPERATION:程序对象未能成功连接</li>
          <li>-1：指定的attribute变量不存在，或者其命名具有gl_或webgl_前缀</li>
        </ul>
      </div>
    </section>
    <section id="vertexAttrib[1234]f">
      <h4>gl.vertexAttrib[1234]f(location, v0, v1, v2, v3);</h4>
      <p>
        将数据（v0，v1，v2,v3）传给由location参数指定的attribute变量，如果没有传递后面的
        v1, v2, v3，使用默认值0.0、0.0、1.0
      </p>
      <div class="content">
        <strong>参数：</strong>
        <ul>
          <li>location：指定将要修改的attribute变量的存储位置</li>
          <li>v0：指定填充attribute变量第一个分量的值</li>
          <li>v1：指定填充attribute变量第二个分量的值</li>
          <li>v2：指定填充attribute变量第三个分量的值</li>
          <li>v3：指定填充attribute变量第四个个分量的值</li>
        </ul>
        <strong>返回值：</strong>
        <p>无</p>
        <strong>错误：</strong>
        <ul>
          <li>INVALID_OPERATION:程序对象未能成功连接（没有当前program对象）</li>
          <li>INVALID_VALUE：location大于等于attribute变量名的最大数目（默认为8）</li>
        </ul>
        <strong>矢量方法：</strong>
        <ul>
          <li>gl.vertexAttrib1fv(location,Float32Array);</li>
          <li>gl.vertexAttrib4fv(location,Float32Array);</li>
          <li>
            <strong>实例：</strong>
            <p>var position = new Float32Array([0.0,0.0,0.0,1.0]);</p>
            <p>gl.vertexAttrib4fv(a_Position, position);</p>
          </li>
        </ul>
      </div>
    </section>
    <section id="vertexAttribPointer">
      <h4>gl.vertexAttribPointer(location, size, type, normalized, stride, offset);</h4>
      <p>
        将绑定到gl.ARRAY_BUFFER上的缓存区对象分配给由location指定的attribute变量
      </p>
      <div class="content">
        <strong>参数：</strong>
        <ul>
          <li>location：指定待分配attribute变量的存储位置</li>
          <li>size：指定缓存区中每个顶点的分量个数（1到4）。若size比attribute变量需要的分量数少，
            缺失分量将按照与vertexAttrib[1234]f（）相同的规则补全。
          </li>
          <li>
            type:用以下类型之一来指定格式
            <p>
              gl.UNSIGNED_BYTE:无符号字节，Unit8Array<br>
              gl.SHORT:短整型，Int16Array<br>
              gl.UNSIGNED_SHORT:无符号短整型，Unit16Array<br>
              gl.INT:无符号整型，Int16Array<br>
              gl.UNSIGNED_INT:无符号整型，Unit16Array<br>
              gl.FLOAT:浮点型，Float32Array<br>
            </p>
          </li>
          <li>normalize：传入true或false，表明是否将非浮点型的数据归一化到[0,1]或[-1,1]区间</li>
          <li>stride：指定相邻两个顶点的字节数，默认为0</li>
          <li>offset：指定缓存区对象中的偏移量（以字节为单位），即attribute变量从缓存区中的何处开始储存，
            如果是起始位置开始的，offset设置为0
          </li>
        </ul>
        <strong>返回值：</strong>
        <p>无</p>
        <strong>错误：</strong>
        <ul>
          <li>INVALID_OPERATION:程序对象未能成功连接（没有当前program对象）</li>
          <li>INVALID_VALUE：location大于等于attribute变量名的最大数目（默认为8）,或则stride或offset是负值</li>
        </ul>
        <strong>实例：</strong>
        <ul>
          <li><a href="../../WebGL编程指南/ch3/MultiPoints.html">绘制三角形的三个顶点</a></li>
        </ul>
      </div>
    </section>
    <!--与uniform变量相关方法-->
    <section id="getUniformLocation">
      <h4>gl.getUniformLocation(program, name);</h4>
      <p>获取指定名称的uniform变量的存储位置</p>
      <div class="content">
        <strong>参数：</strong>
        <ul>
          <li>program：指定包含顶点着色器和片元着色器的着色器程序对象。</li>
          <li>name：指定想要获取其存储位置的uniform变量名称</li>
        </ul>
        <strong>返回值：</strong>
        <ul>
          <li>non-unll:指定uniform变量的位置</li>
          <li>null：指定的uniform变量不存在，或者其命名具有gl_或webgl_前缀</li>
        </ul>
        <strong>错误：</strong>
        <ul>
          <li>INVALID_OPERATION:程序对象未能成功连接</li>
          <li>INVALID_VALUE：name参数的长度大于attribute变量名的最大长度（默认256字节）</li>
        </ul>
      </div>
    </section>
    <section id="uniform">
      <h4>gl.uniform[1234]f(location, v0, v1, v2, v3);</h4>
      <p>将数据（v0，v1，v2,v3）传给由location参数指定的uniform变量</p>
      <div class="content">
        <strong>参数：</strong>
        <ul>
          <li>location：指定将要修改的uniform变量的存储位置</li>
          <li>v0：指定填充uniform变量第一个分量的值</li>
          <li>v1：指定填充uniform变量第二个分量的值</li>
          <li>v2：指定填充uniform变量第三个分量的值</li>
          <li>v3：指定填充uniform变量第四个个分量的值</li>
        </ul>
        <strong>返回值：</strong>
        <p>无</p>
        <strong>错误：</strong>
        <ul>
          <li>INVALID_OPERATION:程序对象未能成功连接，或者localhost是非法的变量的存储位置</li>
        </ul>
      </div>
    </section>
    <section id="uniformMatrix4fv">
      <h4>gl.uniformMatrix4fv(location, transpose, array)</h4>
      <p>将array表示的4X4矩阵分配给由location指定的uniform存储的变量</p>
      <div class="content">
        <strong>参数：</strong>
        <ul>
          <li>location：uniform变量的存储位置</li>
          <li>transpose：在WebGL中必须指定为false。该参数表示是否转置矩阵。转置操作将交换矩阵的行和列，
            WebGL实现没有提供矩阵转置的方法，所以该参数必须设为false
          </li>
          <li>array：待传输的类型化数组，4X4矩阵按列主序存储在其中</li>
        </ul>
        <strong>返回值：</strong>
        <p>无</p>
        <strong>错误：</strong>
        <ul>
          <li>INVALID_OPERATION:不存在当前程序对象</li>
          <li>INVALID_VALUE:transpose不为false，或者数组的长度小于16</li>
        </ul>
        <strong>列子</strong>
        <ul>
          <li><a href="../../WebGL编程指南/ch3/RotatedTriangle_Matrix.html">用矩阵旋转三角形</a></li>
        </ul>
      </div>
    </section>
    <!--与缓存区相关方法-->
    <section id="createBuffer">
      <h4>gl.createBuffer();</h4>
      <p>创建缓存区对象</p>
      <div class="content">
        <strong>返回值：</strong>
        <p>
          非null：新创建的缓存区对象<br>
          null：创建缓存区对象失败
        </p>
        <strong>实例：</strong>
        <ul>
          <li><a href="../../WebGL编程指南/ch3/MultiPoints.html">绘制三角形的三个顶点</a></li>
        </ul>
      </div>
    </section>
    <section id="deleteBuffer">
      <h4>gl.deleteBuffer(buffer);</h4>
      <p>删除参数buffer表示的缓存区对象</p>
      <div class="content">
        <strong>参数：</strong>
        <ul>
          <li>buffer：待删除的缓存区对象</li>
        </ul>
        <strong>返回值：</strong>
        <p>无</p>
        <strong>实例：</strong>
        <ul>
          <li><a href="../../WebGL编程指南/ch3/MultiPoints.html">绘制三角形的三个顶点</a></li>
        </ul>
      </div>
    </section>
    <section id="bindBuffer">
      <h4>gl.bindBuffer(target, buffer);</h4>
      <p>允许使用buffer表示的缓存区对象并将其绑定到target表示的目标上</p>
      <div class="content">
        <strong>参数：</strong>
        <ul>
          <li>
            target
            <p>
              gl.ARRAY_BUFFER：表示缓存区对象中包含来顶点的数据<br>
              gl.ELEMENT_ARRAY_BUFFER:表示缓存区对象中包含了顶点的索引值"OpenGL ES着色器语言[GLSL ES]"
            </p>
          </li>
          <li>buffer:指定之前🈶️由gl.createBuffer()返回的待绑定的缓存区对象，如果指定为空，则禁用对target的绑定</li>
        </ul>
        <strong>返回值：</strong>
        <p>无</p>
        <strong>错误：</strong>
        <ul>
          <li>INVALID_ENUM target不是上诉值之一，这时将保持原有的绑定情况不变</li>
        </ul>
        <strong>实例：</strong>
        <ul>
          <li><a href="../../WebGL编程指南/ch3/MultiPoints.html">绘制三角形的三个顶点</a></li>
        </ul>
      </div>
    </section>
    <section id="enableVertexAttribArray">
      <h4>gl.enableVertexAttribArray(location)</h4>
      <p>
        开启location指定的attribute变量
      </p>
      <div class="content">
        <strong>参数：</strong>
        <ul>
          <li>location：指定待分配attribute变量的存储位置</li>
        </ul>
        <strong>返回值：</strong>
        <p>无</p>
        <strong>错误：</strong>
        <ul>
          <li>INVALID_VALUE：location大于等于attribute变量名的最大数目（默认为8）</li>
        </ul>
        <strong>实例：</strong>
        <ul>
          <li><a href="../../WebGL编程指南/ch3/MultiPoints.html">绘制三角形的三个顶点</a></li>
        </ul>
      </div>
    </section>
    <section id="disableVertexAttribArray">
      <h4>gl.disableVertexAttribArray(location)</h4>
      <p>
        关闭location指定的attribute变量
      </p>
      <div class="content">
        <strong>参数：</strong>
        <ul>
          <li>location：指定attribute变量的存储位置</li>
        </ul>
        <strong>返回值：</strong>
        <p>无</p>
        <strong>错误：</strong>
        <ul>
          <li>INVALID_VALUE：location大于等于attribute变量名的最大数目（默认为8）</li>
        </ul>
        <strong>实例：</strong>
        <ul>
          <li><a href="../../WebGL编程指南/ch3/MultiPoints.html">绘制三角形的三个顶点</a></li>
        </ul>
      </div>
    </section>
    <!--与加载纹理相关的方法-->
    <section id="createTexture">
      <h4>gl.createTexture()</h4>
      <p>创建纹理对象以存储纹理图像</p>
      <div class="content">
        <strong>参数</strong>
        <p>无</p>
        <strong>返回值</strong>
        <ul>
          <li>non-null:新创建的纹理对象</li>
          <li>null:创建纹理对象失败</li>
        </ul>
        <strong>错误</strong>
        <p>无</p>
      </div>
    </section>
    <section id="deleteTexture">
      <h4>gl.deleteTexture(texture)</h4>
      <p>使用texture删除纹理对象</p>
      <div class="content">
        <strong>参数</strong>
        <p>texture：待删除的纹理对象</p>
        <strong>返回值</strong>
        <p>无</p>
        <strong>错误</strong>
        <p>无</p>
      </div>
    </section>
    <section id="pixelStorei">
      <h4>gl.pixelStorei(pname,param)</h4>
      <p>使用pname和param指定的方式处理加载得到的图像</p>
      <div class="content">
        <strong>参数</strong>
        <ul>
          <li>
            panme:可以是以下二者之一<br>
            gl.UNPACK_FLIP_Y_WEBGL:对图像进行Y轴反转。默认为false。<br>
            gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL:将图像RGB颜色值的每一个分量乘以A。默认值为false。
          </li>
          <li>param:指定非0（true）或0（false）。必须为整数。</li>
        </ul>
        <strong>返回值</strong>
        <p>无</p>
        <strong>错误</strong>
        <p>INVALID_ENUM：pname不是合法的值</p>
      </div>
    </section>
    <section id="activeTexture">
      <h4>gl.activeTexture(texUnit)</h4>
      <p>激活texUnit指定的纹理单元</p>
      <div class="content">
        <strong>参数</strong>
        <ul>
          <li>
            texUnit：指定准备激活的纹理单元：gl.TEXTURE0、gl.TEXTURE1、gl.TEXTURE2、
            gl.TEXTURE03、gl.TEXTURE4、gl.TEXTURE5、gl.TEXTURE6、gl.TEXTURE7。
            最后的数字表示纹理单元的编号。
          </li>
        </ul>
        <strong>返回值</strong>
        <p>无</p>
        <strong>错误</strong>
        <p>INVALID_ENUM：texUnit不是合法的值</p>
      </div>
    </section>
    <section id="bindTexture">
      <h4>gl.bindTexture(target,texture)</h4>
      <p>
        开启texture指定的纹理对象，并将其绑定到target上。此外，如果已经通过gl.activeTexture()激活
        了某个纹理单元，则纹理对象也会绑定到这个纹理单元上。
      </p>
      <div class="content">
        <strong>参数</strong>
        <ul>
          <li>target：gl.TEXTURE_2D或者gl.TEXTURE_BUVE_MAP</li>
          <li>texture：表示绑定的纹理单元</li>
        </ul>
        <strong>返回值</strong>
        <p>无</p>
        <strong>错误</strong>
        <p>INVALID_ENUM：target不是合法的值</p>
      </div>
    </section>
    <section id="texParameteri">
      <h4>gl.texParameteri(target,pname，param)</h4>
      <p>将param的值赋给绑定到目标的纹理对象的pname参数上。</p>
      <div class="content">
        <strong>参数</strong>
        <ul>
          <li>target：gl.TEXTURE_2D或者gl.TEXTURE_BUVE_MAP</li>
          <li>
            pname：纹理参数
            <table border="1">
              <tr>
                <th colspan="3">纹理参数及它们的默认值</th>
              </tr>
              <tr>
                <th>纹理参数</th>
                <th>描述</th>
                <th>默认值</th>
              </tr>
              <tr>
                <td>gl.TEXTURE_MAG_FILTER</td>
                <td>纹理的放大</td>
                <td>gl.LINEAR</td>
              </tr>
              <tr>
                <td>gl.TEXTURE_MIN_FILTER</td>
                <td>纹理的缩小</td>
                <td>gl.NEAREST_MIPMAP_LINEAR</td>
              </tr>
              <tr>
                <td>gl.TEXTURE_WRAP_S</td>
                <td>纹理水平填充</td>
                <td>gl.REPEAT</td>
              </tr>
              <tr>
                <td>gl.TEXTURE_WRAP_T</td>
                <td>纹理垂直填充</td>
                <td>gl.REPEAT</td>
              </tr>
            </table>
          </li>
          <li>param：纹理参数值
            <table border="1">
              <tr>
                <th colspan="2">可以赋值给gl.TEXTURE_MAG_FILTER和gl.TEXTURE_MIN_FILTER的非金字塔纹理类型常量</th>
              </tr>
              <tr>
                <th>值</th>
                <th>描述</th>
              </tr>
              <tr>
                <td>gl.NEAREST</td>
                <td>使用原纹理上距离映射后像素（新像素）中心最近的那个颜色值，作为新像素的值（使用曼哈顿距离）</td>
              </tr>
              <tr>
                <td>gl.LINEAR</td>
                <td>使用距离新像素中心最近的四个像素的颜色值的加权平均，作为新像素的值（与gl.NEAREST相比，该方法图像质量更好，但会有较大的开销）</td>
              </tr>
              <tr>
                <th colspan="2">可以赋值给gl.TEXTURE_WRAP_S和gl.TEXTURE_WRAP_T的常量</th>
              </tr>
              <tr>
                <td>值</td>
                <td>描述</td>
              </tr>
              <tr>
                <td>gl.REPEAT</td>
                <td>平铺式的重复纹理</td>
              </tr>
              <tr>
                <td>gl.MIRRORED_REPEAT</td>
                <td>镜像对称式的重复纹理</td>
              </tr>
              <tr>
                <td>gl.CLAMP_TO_EDGE</td>
                <td>使用纹理图像边缘值</td>
              </tr>
            </table>
          </li>
        </ul>
        <strong>返回值</strong>
        <p>无</p>
        <strong>错误</strong>
        <p>INVALID_ENUM：target不是合法的值</p>
        <p>INVALID_OPERATION：当前目标上没有绑定纹理对象</p>
      </div>
    </section>
    <section id="texImage2D">
      <h4>gl.texImage2D(target，level, internalformat, format,type,image)</h4>
      <p>将image指定的图像分配给绑定的目标上的纹理对象。</p>
      <div class="content">
        <strong>参数</strong>
        <ul>
          <li>target: gl.TEXTURE_2D或gl.TEXTURE_CUBE_MAP</li>
          <li>level: 出入0（实际上该参数是为金字塔纹理准备的）</li>
          <li>internalformat: 图像的内部格式</li>
          <li>
            format: 纹理数据的格式，必须使用与internalformat相同的值
            <table border="1">
              <tr>
                <th colspan="2">文素数据的格式</th>
              </tr>
              <tr>
                <th>格式</th>
                <th>描述</th>
              </tr>
              <tr>
                <td>gl.RGB</td>
                <td>红、绿、蓝</td>
              </tr>
              <tr>
                <td>gl.RGBA</td>
                <td>红、绿、蓝、透明度</td>
              </tr>
              <tr>
                <td>gl.ALPHA</td>
                <td>（0.0,0.0,0.0,透明度）</td>
              </tr>
              <tr>
                <td>gl.LUMINANCE</td>
                <td>L、L、L、1L：流明（表示我们感知到的物体表面的亮度。通常使用物体表面红、绿、蓝颜色分量值的加权平均来计算流明）</td>
              </tr>
              <tr>
                <td>gl.LUMINANCE_ALPHA</td>
                <td>L、L、L、透明度</td>
              </tr>
            </table>
            <table border="1">
              <tr>
                <th colspan="2">纹理图片格式说明</th>
              </tr>
              <tr>
                <th>格式</th>
                <th>像素表示方法</th>
              </tr>
              <tr>
                <td>JPG格式</td>
                <td>RGB</td>
              </tr>
              <tr>
                <td>PNG格式</td>
                <td>RGBA</td>
              </tr>
              <tr>
                <td>BMP格式</td>
                <td>RGB</td>
              </tr>
            </table>
          </li>
          <li>type: 纹理数据类型
          <table border="1">
            <tr>
              <th colspan="2">纹理数据的数据格式</th>
            </tr>
            <tr>
              <th>格式</th>
              <th>描述</th>
            </tr>
            <tr>
              <td>gl.UNSIGNED_BYTE</td>
              <td>无符号整型，每个颜色分量占据1字节</td>
            </tr>
            <tr>
              <td>gl.UNSIGNED_SHORT_5_6_5</td>
              <td>RGB:每个分量分别占用5、6、5比特</td>
            </tr>
            <tr>
              <td>gl.UNSIGNED_SHORT_4_4_4_4</td>
              <td>RGB:每个分量分别占用4、4、4、4比特</td>
            </tr>
            <tr>
              <td>gl.UNSIGNED_SHORT_5_5_5_1</td>
              <td>RGB:RGB每个分量分别占用5、5、5比特，A分量占据1比特</td>
            </tr>
          </table>
          </li>
          <li>image: 包含纹理图像的Image对象</li>
        </ul>
        <strong>返回值</strong>
        <p>无</p>
        <strong>错误</strong>
        <ul>
          <li>INVALID_ENUM:target不是合法的</li>
          <li>INVALID_OPERATION:当前目标上没有绑定纹理对象</li>
        </ul>
      </div>
    </section>
  </div>
</div>
</body>
</html>